/**
 * 运算器
 * 
 * + - * / （ ） 
 */

let input = "-1 + 2 * （ 2 + 2 * 2 ）- 1 ";

let operaterLevel = {
  "+": 0,
  "-": 0,
  "*": 1,
  "/": 1,
  "(": 2,
  ")": 2
}

function calculate(s) {
  let num = 0, n = s.length;
  let ops = []; // 运算符栈
  let nums = [0];
  for (let i = 0; i < n; i++) {
    if (i < n && !isNaN(Number(s[i])) && i !== " ") {
      num = num * 10 + s[i].charCodeAt() - "0".charCodeAt();
    }
    if (isNaN(Number(s[i]))) {
      // TODO 处理数字与运算符
    }
  }
  
}


/**
 * 双栈解法 
  对于「表达式计算」这一类问题，你都可以使用这套思路进行解决。我十分建议你加强理解这套处理逻辑。

  对于「任何表达式」而言，我们都使用两个栈 nums 和 ops：

  nums ： 存放所有的数字
  ops ：存放所有的数字以外的操作
  然后从前往后做，对遍历到的字符做分情况讨论：

  空格 : 跳过
  ( : 直接加入 ops 中，等待与之匹配的 )
  ) : 使用现有的 nums 和 ops 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums
  数字 : 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 nums
  + - * / ^ % : 需要将操作放入 ops 中。在放入之前先把栈内可以算的都算掉（只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算），使用现有的 nums 和 ops 进行计算，直到没有操作或者遇到左括号，计算结果放到 nums
  我们可以通过 🌰 来理解 只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算 是什么意思：

  因为我们是从前往后做的，假设我们当前已经扫描到 2 + 1 了（此时栈内的操作为 + ）。

  如果后面出现的 + 2 或者 - 1 的话，满足「栈内运算符」比「当前运算符」优先级高/同等，可以将 2 + 1 算掉，把结果放到 nums 中；
  如果后面出现的是 * 2 或者 / 1 的话，不满足「栈内运算符」比「当前运算符」优先级高/同等，这时候不能计算 2 + 1。
  一些细节：

  由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 nums 添加一个 0
  为防止 () 内出现的首个数字为负数，将所有的空格去掉，并将 (- 替换为 (0- （LeetCode 测试样例中没有出现这类数据）
  从理论上分析，nums 最好存放的是 long，而不是 int。因为可能存在 大数 + 大数 + 大数 + … - 大数 - 大数 的表达式导致中间结果溢出，最终答案不溢出的情况（LeetCode 测试样例中没有出现这类数据）

  */